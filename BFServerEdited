#include <arpa/inet.h>
#include <sqlite3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define PORT 8080
#define MAX_CLIENTS 10

sqlite3 *db; // Global database connection

// Function to close the database connection
void close_db() {
    if (db != NULL) {
        sqlite3_close(db);
        db = NULL;
        printf("Database connection closed.\n");
    }
}

// Initialize the database
void init_db() {
    int rc = sqlite3_open("bookstore.db", &db);
    if (rc) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        exit(0);
    } else {
        printf("Database connection opened successfully.\n");
    }

    // Create users table
    const char *users_table = "CREATE TABLE IF NOT EXISTS users ("
                              "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                              "name TEXT, "
                              "password TEXT);";
    sqlite3_exec(db, users_table, 0, 0, 0);

    // Create books table
    const char *books_table = "CREATE TABLE IF NOT EXISTS books ("
                              "id INTEGER PRIMARY KEY, "
                              "name TEXT, "
                              "author TEXT, "
                              "return_date INTEGER, "
                              "availability INTEGER);";
    sqlite3_exec(db, books_table, 0, 0, 0);

    // Create rented_books table
    const char *rented_books_table = "CREATE TABLE IF NOT EXISTS rented_books ("
                                     "user_id INTEGER, "
                                     "book_id INTEGER, "
                                     "FOREIGN KEY (user_id) REFERENCES users(id), "
                                     "FOREIGN KEY (book_id) REFERENCES books(id));";
    sqlite3_exec(db, rented_books_table, 0, 0, 0);
}

// Function to prepopulate books table
void initialize_books() {
    sqlite3_stmt *stmt;
    const char *check_sql = "SELECT COUNT(*) FROM books;";
    sqlite3_prepare_v2(db, check_sql, -1, &stmt, 0);
    sqlite3_step(stmt);
    int count = sqlite3_column_int(stmt, 0);
    sqlite3_finalize(stmt);

    if (count == 0) {
        const char *insert_sql =
            "INSERT INTO books (id, name, author, return_date, availability) "
            "VALUES "
            "(1, 'C Programming', 'Dennis Ritchie', 0, 5),"
            "(2, 'Data Structures', 'Mark Allen Weiss', 0, 3),"
            "(3, 'Algorithms', 'Robert Sedgewick', 0, 4),"
            "(4, 'Operating Systems', 'Andrew Tanenbaum', 0, 6),"
            "(5, 'Computer Networks', 'James Kurose', 0, 2),"
            "(6, 'Artificial Intelligence', 'Stuart Russell', 0, 5),"
            "(7, 'Machine Learning', 'Tom Mitchell', 0, 3),"
            "(8, 'Database Systems', 'Raghu Ramakrishnan', 0, 4),"
            "(9, 'Software Engineering', 'Ian Sommerville', 0, 5),"
            "(10, 'Computer Graphics', 'Donald Hearn', 0, 3);";
        sqlite3_exec(db, insert_sql, 0, 0, 0);
        printf("Books added to the database.\n");
    }
}

// Create account without ZIP code
void create_account(int client_socket, char name[]) {
    char buffer[1024] = {0};
    char username[50], password[50];

    // Get username
    send(client_socket, "Enter a username: ", 18, 0);
    read(client_socket, buffer, 1024);
    sscanf(buffer, "%s", username);

    // Check if username already exists
    char check_sql[256];
    snprintf(check_sql, sizeof(check_sql),
             "SELECT COUNT(*) FROM users WHERE name='%s';", username);

    sqlite3_stmt *stmt;
    sqlite3_prepare_v2(db, check_sql, -1, &stmt, NULL);
    sqlite3_step(stmt);
    int user_count = sqlite3_column_int(stmt, 0);
    sqlite3_finalize(stmt);

    if (user_count > 0) {
        send(client_socket, "Username already exists. Try another one.\n", 43, 0);
        return;
    }

    // Get password
    send(client_socket, "Enter a password: ", 18, 0);
    memset(buffer, 0, sizeof(buffer));
    read(client_socket, buffer, 1024);
    sscanf(buffer, "%s", password);

    // Insert new user
    char insert_sql[256];
    snprintf(insert_sql, sizeof(insert_sql),
             "INSERT INTO users (name, password) VALUES ('%s', '%s');",
             username, password);
    sqlite3_exec(db, insert_sql, 0, 0, 0);

    strncpy(name, username, 50);
    send(client_socket, "Account created successfully\n", 29, 0);
}

// Handle client interactions
void handle_client(int client_socket) {
    char buffer[1024] = {0};
    int option, login_success = 0;
    char name[50] = {0};

    while (!login_success) {
        const char *welcome_message = "\nWelcome to the Library Database!\n Please, choose an option:\n1. Login\n2. Create Account\n5. Exit\n";
        send(client_socket, welcome_message, strlen(welcome_message), 0);

        memset(buffer, 0, sizeof(buffer));
        read(client_socket, buffer, sizeof(buffer));
        option = atoi(buffer);

        switch (option) {
            case 1: // Login
                if (!login(client_socket, name)) {
                    send(client_socket, "Login failed. Returning to the main menu.\n", 42, 0);
                } else {
                    login_success = 1;
                }
                break;
            case 2: // Create Account
                create_account(client_socket, name);
                send(client_socket, "Returning to the main menu.\n", 28, 0);
                break;
            case 5: // Exit
                send(client_socket, "Exiting...\n", 11, 0);
                close(client_socket);
                return;
            default:
                send(client_socket, "Invalid option. Try again.\n", 28, 0);
                break;
        }
    }

    while (1) {
        const char *menu_message = "\nYou have successfully logged in!\nPlease choose an option:\n1. Review Account Information\n2. View Books\n3. Rent Book\n4. Return Book\n5. Exit\n";
        send(client_socket, menu_message, strlen(menu_message), 0);

        memset(buffer, 0, sizeof(buffer));
        read(client_socket, buffer, sizeof(buffer));
        option = atoi(buffer);

        switch (option) {
            case 1:
                display_account_info(client_socket, name);
                break;
            case 2:
                find_books(client_socket);
                break;
            case 3:
                rent_book(client_socket, get_user_id(name));
                break;
            case 4:
                return_book(client_socket, get_user_id(name));
                break;
            case 5:
                send(client_socket, "Exiting...\n", 11, 0);
                close(client_socket);
                return;
            default:
                send(client_socket, "Invalid option. Try again.\n", 28, 0);
                break;
        }
    }
}

int main() {
    init_db();
    initialize_books();

    int server_fd, client_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, MAX_CLIENTS) < 0) {
        perror("listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server is listening on port %d\n", PORT);

    while (1) {
        if ((client_socket = accept(server_fd, (struct sockaddr *)&address,
                                    (socklen_t *)&addrlen)) < 0) {
            perror("accept failed");
            continue;
        }

        if (fork() == 0) {
            close(server_fd);
            handle_client(client_socket);
            close_db(); // Close database in child process
            exit(0);
        }
        close(client_socket);
    }

    close_db(); // Close database at the end
    return 0;
}

